

(function (window) {

    var fruskac = function () {
    };

    fruskac.prototype = fruskac;

    window.fruskac = fruskac;

})(window);


(function (fruskac) {

    var TYPE = {
        MARKER: 'marker',
        TRACK: 'track',
        KML: 'kml'
    };

    fruskac.prototype.TYPE = (function () {
        return TYPE;
    })();

})(window.fruskac);


(function (google) {

    /**
     * Extend google.maps.Polyline to get bounds based on path
     *
     * @returns {google.maps.LatLngBounds}
     */
    google.maps.Polyline.prototype.getBounds = function () {
        var bounds = new google.maps.LatLngBounds();
        this.getPath().forEach(function (item) {
            bounds.extend(new google.maps.LatLng(item.lat(), item.lng()));
        });
        return bounds;
    };


})(google);


(function (fruskac, google) {

    /**
     *
     * @param {Object|undefined} options
     * @constructor
     */
    var Marker = function (options) {

        options = _.extend({
            map: fruskac.map.getMap()
        }, options);

        var icon;

        switch (options.icon) {
            case 'lakes':
                icon = 'mm_20_purple';
                break;
            case 'monasteries':
                icon = 'mm_20_yellow';
                break;
            case 'misc':
                icon = 'mm_20_blue';
                break;
            case 'springs':
                icon = 'mm_20_white';
                break;
            case 'picnic-areas':
                icon = 'mm_20_green';
                break;
            case 'monuments':
                icon = 'mm_20_red';
                break;
            case 'fishponds':
                icon = 'mm_20_black';
                break;
            case 'waterfalls':
                icon = 'mm_20_orange';
                break;
            case 'lookouts':
                icon = 'mm_20_gray';
                break;
            case 'meadows':
                icon = 'mm_20_brown';
                break;
            default:
                icon = 'mm_20_white';
                break;
        }

        options.icon = 'http://maps.gstatic.com/mapfiles/ridefinder-images/' + icon + '.png'

        return (function () {

            var marker = new google.maps.Marker(options);

            google.maps.event.addListener(marker, 'click', function () {
                Map.showInfoWindow(getInfoWindowContent(options.data), this);
            });

            return marker;

        })();
    };

    /**
     * Creates HTML that will be presented on InfoWindow
     *
     * @param {Object} data
     * @returns {string}
     */
    function getInfoWindowContent(data) {
        var html = '<h1>' + data.title + '</h1>';
        if (data.description) {
            html += '<p>' + data.description + '</p>';
        }
        if (data.image) {
            html += '<img src="' + data.image + '">';
        }
        if (data.link) {
            html += '<a href="' + data.link + '" target="_blank">' + data.link + '</a>';
        }
        return html;
    }

    fruskac.prototype.Marker = Marker;

})(window.fruskac, google);


(function (fruskac) {

    /**
     * Track
     *
     * @param {Object|undefined} options
     * @constructor
     */
    var Track = function (options) {

        options = _.extend({
            map: fruskac.map.getMap(),
            geodesic: true,
            strokeColor: 'rgb(51, 102, 204)',
            strokeOpacity: 1.0,
            strokeWeight: 4
        }, options);

        return (function () {
            return new google.maps.Polyline(options)
        })();
    };

    fruskac.prototype.Track = Track;

})(fruskac);


(function (fruskac, google) {

    /**
     *
     * @param {string} url
     * @param {Object|undefined} options
     * @constructor
     */
    function Kml(url, options) {

        options = _.extend({
            map: fruskac.map.getMap(),
            preserveViewport: true,
            suppressInfoWindows: true,
            data: {
                type: 'kml'
            }
        }, options);

        return (function () {
            return new google.maps.KmlLayer(url, options)
        })();
    }

    fruskac.prototype.Kml = Kml;

})(window.fruskac, google);


(function (window, $, google, fruskac) {

    /**
     *
     * @param {HTMLDomElement} container
     * @constructor
     */
    var Chart = function (container) {
        this.visible = false;
        this.container = container;
        this.map = fruskac.map.getMap();

        $(this.container)
            .append('<button onclick="fruskac.chart.setVisible(false)">X</button>')
            .append('<div id="chart_content"></div>');

    };

    Chart.prototype = {

        /**
         * Set chart container visibility
         *
         * @param {boolean} value
         */
        setVisible: function (value) {

            this.visible = value;

            var className = 'on';

            if (this.visible) {
                $(this.container).addClass(className);
            } else {
                $(this.container).removeClass(className);
            }

            var center = this.map.getCenter();
            google.maps.event.trigger(this.map, "resize");
            this.map.setCenter(center);

        },

        /**
         * Show chart
         *
         * @param {array} points
         */
        show: function (points) {

            this.setVisible(true);

            var elevator = new google.maps.ElevationService;

            // Load the Visualization API and the corechart package.
            google.charts.load('current', {'packages': ['corechart']});

            // Set a callback to run when the Google Visualization API is loaded.
            google.charts.setOnLoadCallback(function () {
                getPathElevation(points, elevator, function (rows) {

                    // Create the data table.
                    var data = new google.visualization.DataTable();
                    data.addColumn('number', 'Distance');
                    data.addColumn('number', 'Elevation');
                    data.addRows(rows);

                    // Set chart options
                    var options = {
                        lineWidth: 5,
                        focusTarget: 'category',
                        hAxis: {
                            title: 'Distance (km)'
                        },
                        vAxis: {
                            title: 'Elevation (m)',
                            minValue: 0
                        },
                        legend: {
                            position: "none"
                        }
                    };

                    // Instantiate and draw our chart, passing in some options.
                    var chart = new google.visualization.AreaChart(document.getElementById('chart_content'));
                    chart.draw(data, options);

                    google.visualization.events.addListener(chart, 'onmouseover', function (coords) {
                        fruskac.map.placeMarker(points.getAt(coords.row))
                    });

                });
            });


        }
    };


    /**
     *
     * @param {Object[]} points
     * @param {google.maps.ElevationService} elevator
     * @param {Function} callback
     */
    function getPathElevation(points, elevator, callback) {

        var gpath = [];
        points.forEach(function (point) {
            gpath.push(point)
        });

        // Create a PathElevationRequest object using this array.
        elevator.getElevationAlongPath({
            'path': gpath,
            'samples': gpath.length
        }, function (elevations) {
            var distance = 0;
            var rows = [];
            elevations.forEach(function (e, index) {
                var distanceFromPrevious;
                if (index) {
                    distanceFromPrevious = getDistance(elevations[index].location, elevations[index - 1].location)
                } else {
                    distanceFromPrevious = 0;
                }
                distance += parseFloat(distanceFromPrevious);
                rows.push([distance, e.elevation]);
            });
            callback(rows);
        });
    }

    /**
     * calculates distance between two points in km's
     *
     * @param {google.maps.LatLng} p1
     * @param {google.maps.LatLng} p2
     * @returns {string}
     */
    function getDistance(p1, p2) {
        var R = 6378137; // Earthâ€™s mean radius in meter
        var dLat = rad(p2.lat() - p1.lat());
        var dLong = rad(p2.lng() - p1.lng());
        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(rad(p1.lat())) * Math.cos(rad(p2.lat())) *
            Math.sin(dLong / 2) * Math.sin(dLong / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var d = R * c;
        return (d / 1000).toFixed(2); // "d" returns the distance in meter
        //return (google.maps.geometry.spherical.computeDistanceBetween(p1, p2) / 1000).toFixed(2);
    }

    /**
     *
     * @param {number} x
     * @returns {number}
     */
    function rad(x) {
        return x * Math.PI / 180;
    }

    fruskac.prototype.Chart = Chart;

})(window, jQuery, google, window.fruskac);


(function (window, fruskac) {

    /**
     * Map
     * @param {google.maps.Map} map
     * @constructor
     */
    var Map = function (map) {
        this.map = map;

        this.infoWindow = new google.maps.InfoWindow({
            content: "holding..."
        });

    };

    Map.prototype = {

        /**
         * Add object to map
         * @param {Object} data
         * @param {string} type
         * @param {boolean} visible
         * @returns {Promise}
         */
        add: function (data, type, visible) {

            var self = this;

            return new Promise(function (resolve) {
                switch (type) {
                    case fruskac.TYPE.MARKER:
                        return self.addMarker(data, visible).then(function (marker) {
                            resolve(marker);
                        });
                        break;
                    case fruskac.TYPE.TRACK:
                        return self.addTrack(data, visible).then(function (track) {
                            resolve(track);
                        });
                        break;
                    case fruskac.TYPE.KML:
                        return self.addKml(data, visible).then(function (kml) {
                            resolve(kml);
                        });
                        break;
                }
            });

        },

        /**
         * Add marker to map
         * @param {Object} data
         * @param {boolean} visible
         * @returns {Promise}
         */
        addMarker: function (data, visible) {

            return new Promise(function (resolve) {
                var marker = new fruskac.Marker({
                    position: new google.maps.LatLng(data.lat, data.lng),
                    title: data.data.title,
                    icon: data.tag,
                    data: data.data
                });

                marker.setVisible(visible);

                fruskac.clusterer.addMarker(marker);

                resolve(marker);

            })

        },

        /**
         * Add track to map
         * @param {Object} data
         * @param {boolean} visible
         * @returns {Promise}
         */
        addTrack: function (data, visible) {

            return new Promise(function (resolve) {

                return $.get('../' + data.url).then(function (response) {
                    var points = [];
                    $(response).find('trkpt').each(function (i, v) {
                        var lat = Number($(this).attr('lat'));
                        var lon = Number($(this).attr('lon'));
                        var p = new google.maps.LatLng(lat, lon);
                        points.push(p);
                    });

                    var track = new fruskac.Track({
                        path: points
                    });

                    track.setVisible(visible);

                    resolve(track);

                });

            });

        },

        /**
         * Add KML layer to map
         * @param {Object} data
         * @param {boolean} visible
         * @returns {Promise}
         */
        addKml: function (data, visible) {

            return new Promise(function (resolve) {

                var kml = new fruskac.Kml(data.url);

                if (!visible) {
                    kml.setMap(null);
                }

                resolve(kml);

            })

        },

        /**
         * Set visibility on object
         * @param {Object} object
         * @param {boolean} value
         */
        setVisible: function (object, value) {
            if (object.hasOwnProperty('position')) {//marker
                object.setVisible(value);
                if (value) {
                    fruskac.clusterer.addMarker(object);
                } else {
                    fruskac.clusterer.removeMarker(object);
                }
            } else if (object.hasOwnProperty('strokeColor')) {
                object.setVisible(value);
            } else if (object.hasOwnProperty('suppressInfoWindows')) {
                object.setMap(value ? this.map : null);
            }
        },

        /**
         * Get map
         * @returns {*}
         */
        getMap: function () {
            return this.map;
        },

        /**
         * Focus one object on map, fit bounds
         * @param {Object} object
         */
        focus: function (object) {
            this.map.fitBounds(object.getBounds());
            fruskac.chart.show(object.getPath())
        },

        /**
         * Place marker on map
         * @param {google.maps.LatLng} point
         */
        placeMarker: function (point) {
            if (!this.marker) {
                this.marker = new fruskac.Marker({
                    position: point
                });
            } else {
                this.marker.animateTo(point, {
                    duration: 50
                });
            }
        },

        /**
         * Show info window for Marker
         * @param {string} html
         * @param {google.maps.Marker} marker
         */
        showInfoWindow: function (html, marker) {
            this.infoWindow.setContent(html);
            this.infoWindow.open(this.map, marker)
        }
    };

    fruskac.Map = Map;

})(window, window.fruskac);


(function (window, fruskac) {
    /**
     * @param {Array} Initial data array
     * @constructor
     */
    function Storage(data) {
        if (!data) {
            data = [];
        }
        this.data = data;
    }

    Storage.prototype = {

        /**
         * Add object to storage
         * @param {Object} value
         * @param {Array|string} selector
         * @param {string} type
         * @param {boolean} visible
         * @returns {*}
         */
        add: function (value, selector, type, visible) {

            var self = this;

            selector = parseSelector(selector);

            var container;

            if (selector) {
                var object = self.get(selector);
                if (object) {
                    if (!object.children) {
                        object.children = [];
                    }
                    container = object.children;
                }
            } else {
                container = self.data;
            }

            if (type) {
                object.type = type;
                return fruskac.map.add(value, type, visible).then(function (object) {
                    container.push(object);
                });
            } else {
                return new Promise(function (resolve) {
                    container.push(value);
                    resolve(value);
                })
            }

        },

        /**
         * Gets root data array
         * @returns {*}
         */
        root: function () {
            return this.data;
        },

        /**
         * Gets object based on selector and container
         * @param {Array|string} selector
         * @param {Array} container
         * @returns {*}
         */
        get: function (selector, container) {

            selector = parseSelector(selector);

            if (!container) {
                container = this.data;
            }

            if (!selector) {
                return;
            }

            if (selector.indexOf(':') !== -1) {
                var selectorParts = selector.split(':');
                var container = _.find(container, {id: selectorParts[0]}).children;
                selectorParts = selectorParts.splice(1);
                return this.get(selectorParts.join(':'), container);
            }

            return _.find(container, {id: selector});

        },

        /**
         * Gets children based on selector and container
         * @param {Array|string} selector
         * @param {Array} container
         * @returns {*|Array|HTMLElement[]}
         */
        query: function (selector, container) {

            selector = parseSelector(selector);

            if (!container) {
                container = this.data;
            }

            var object = this.get(selector, container);

            return object.children;

        },

        /**
         * Set state (on/off)
         * @param {Array|string} selector
         * @param {boolean} value
         */
        setState: function (selector, value) {

            selector = parseSelector(selector);

            var object = this.get(selector);

            if (object) {
                object.on = value;
                this.setVisible(selector, value);
            }

        },

        /**
         * Get state
         * @param {Array|string} selector
         * @returns {*}
         */
        getState: function (selector) {

            selector = parseSelector(selector);

            var object = this.get(selector);

            if (object) {
                return object.on;
            }

        },

        /**
         * Set visibility
         * @param {Array|string} selector
         * @param {boolean} value
         */
        setVisible: function (selector, value) {

            selector = parseSelector(selector);

            var self = this;

            var object = this.get(selector);

            if (object) {
                object.visible = value;

                if (object.children) {
                    object.children.forEach(function (child) {
                        if (child.id) {
                            self.setVisible([selector, child.id], value)
                        } else {
                            var v = value ? object.on : false;
                            fruskac.map.setVisible(child, v);
                        }
                    })
                }
            }

        },


        /**
         * Get visibility
         * @param {Array|string} selector
         * @returns {boolean}
         */
        getVisible: function (selector) {

            selector = parseSelector(selector);

            var object = this.get(selector);

            var visible = true;

            if (object) {
                visible = object.visible;

                if (hasParentSelector(selector)) {
                    var parentSelector = getParentSelector(selector);
                    var parentVisible = this.getVisible(parentSelector);
                    if (parentVisible) {
                        if (hasParentSelector(parentSelector)) {
                            return this.getVisible(getParentSelector(parentSelector))
                        }
                    } else {
                        return false;
                    }
                }

            }

            return visible;

        },

        /**
         * Select object based on selector
         * @param {Array|string} selector
         */
        select: function (selector) {

            var self = this;

            selector = parseSelector(selector);

            var object = self.get(selector);

            if (hasParentSelector(selector)) {

                var parent = self.get(getParentSelector(selector));

                self.setState(parent.id, true);

                parent.children.forEach(function (child) {
                    self.setState([parent.id, child.id], child.id === object.id);
                });

            }

            fruskac.map.focus(object.children[0])

        },

        getSelectors: function () {
            return getSelectorsForContainer(fruskac.storage.root());
        }
    };

    /**
     * Get parent selector
     * @param {Array|string} selector
     * @returns {string}
     */
    function getParentSelector(selector) {

        selector = parseSelector(selector);

        if (!hasParentSelector(selector)) {
            return;
        }

        var selectorParts = selector.split(':');
        selectorParts.splice(-1);

        return selectorParts.join(':');
    }

    /**
     * Test if parent selector is available
     * @param {Array|string} selector
     * @returns {boolean}
     */
    function hasParentSelector(selector) {

        selector = parseSelector(selector);

        return selector.indexOf(':') !== -1;
    }

    /**
     * Parse array (if provided) into string
     * @param {Array|string} selector
     * @returns {*}
     */
    function parseSelector(selector) {
        if (_.isArray(selector)) {
            selector = selector.join(':');
        }

        return selector;

    }

    /**
     *
     * @param {Array} items
     * @param {Array|string} selector
     * @returns {Array}
     */
    function getSelectorsForContainer(items, selector) {

        selector = parseSelector(selector);

        var children = [];

        items.forEach(function (item) {

            if (!item.id) {
                return;
            }

            var itemSelector;
            if (selector) {
                itemSelector = parseSelector([selector, item.id]);
            } else {
                itemSelector = item.id
            }

            var object = {
                id: item.id,
                getVisible: function () {
                    return fruskac.storage.getState(itemSelector);
                },
                setVisible: function (value) {
                    return fruskac.storage.setState(itemSelector, value);
                },
                select: function () {
                    return fruskac.storage.select(itemSelector);
                }
            };

            if (item.type) {
                object.type = item.type;
            }

            if (item.children && item.children.length) {
                var subChildren = getSelectorsForContainer(item.children, itemSelector);
                if (subChildren && subChildren.length) {
                    object.children = subChildren;
                }
            }

            children.push(object)

        });

        return children;

    }


    fruskac.Storage = Storage;

})(window, window.fruskac);


(function (window, fruskac, TYPE) {

    var storage = fruskac.storage = new fruskac.Storage();

    var map = fruskac.map = new fruskac.Map(new google.maps.Map(document.getElementById('map'), {
        center: new google.maps.LatLng(45.167031, 19.69677),
        zoom: 10,
        mapTypeId: google.maps.MapTypeId.TERRAIN,
        mapTypeControl: false,
        zoomControlOptions: {
            position: google.maps.ControlPosition.LEFT_BOTTOM
        },
        streetViewControlOptions: {
            position: google.maps.ControlPosition.LEFT_BOTTOM
        }
    }));

    var clusterer = fruskac.clusterer = new MarkerClusterer(map.getMap(), [], {
        gridSize: 50,
        imagePath: 'https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m'
    });

    clusterer.enabled = true;

    fruskac.chart = new fruskac.Chart(document.getElementById('chart'));

    load('locations', TYPE.MARKER, true);
    load('marathon', TYPE.TRACK, true);
    load('protection', TYPE.KML, true);
    load('time', TYPE.MARKER, true);

    window.FruskacMap = {
        /**
         * Fired when ready
         * @param {Function} callback
         */
        ready: function (callback) {
            callback();
        },
        /**
         * Get data
         * @returns {Object[]}
         */
        getData: function () {
            return storage.getSelectors();
        },
        /**
         *
         * Get / Set clustering state
         * @param {undefined|boolean} value
         * @returns {*|boolean}
         */
        clustering: function (value) {
            if (value === undefined) { // act as getter
                return clusterer.enabled;
            } else { // act as setter
                clusterer.enabled = value;
                if (value) {
                    clusterer.setMaxZoom(null);
                    clusterer.setGridSize(50);
                } else {
                    clusterer.setMaxZoom(1);
                    clusterer.setGridSize(1);
                }
                clusterer.resetViewport();
                clusterer.redraw();
            }
        },
        /**
         * Get / Set map type
         * @param {undefined|string} value
         * @returns {*}
         */
        type: function (value) {
            if (value === undefined) { // act as getter
                return map.getMap().getMapTypeId();
            } else { // act as setter
                return map.getMap().setMapTypeId(value);
            }
        }
    };

    /**
     * Initialize layers
     * @param {string} name
     * @param {string} type
     * @param {boolean} visible
     */
    function load(name, type, visible) {

        var resource = '../data/' + name + '.json';

        storage.add({
            id: name,
            visible: visible,
            on: visible
        }).then(function () {
            $.get(resource).success(function (response) {
                response.forEach(function (item) {
                    var container = storage.get([name, item.tag]);
                    var promise;
                    if (container) {
                        promise = new Promise(function (resolve) {
                            resolve();
                        })
                    } else {
                        promise = storage.add({
                            id: item.tag,
                            visible: visible,
                            on: visible,
                            type: type
                        }, name)
                    }
                    promise.then(function () {
                        storage.add(item, [name, item.tag], type, visible);
                    });
                })
            })
        });

    }

})(window, window.fruskac, window.fruskac.TYPE);